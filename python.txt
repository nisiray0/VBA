PYTHONではすべてがオブジェクトである

PYTHONでは代入は参照の代入である。

PYTHONでは代入で変数を定義する。

PYTHONの組み込み型
 数値：短整数、長整数、浮動小数点、複素数
 文字列：8ビット文字列、ユニコード文字列
 リスト、タプル、辞書
 BOOL型、SET型、ファイル型

コレクション
 シーケンス：文字列、リスト、タプル
 マップ：辞書
 (文字列とタプルは変更不可）

myfunc=lamda x : x*2+1
            引数  戻り値の式
myfunc(5) 呼出し

RAW文字列 r"C:\Programfile\p.exe"
文字列では、"C:\\Programfile\\p.exe" (エスケープ)

PYTHONでは、複数の要素をカンマ(,)で列挙すると、タプルになる

PYTHONでは丸括弧をつけないで関数名を記述すると、関数をオブジェクトとして
扱える

辞書は、キーをインデックスとして要素を読み出せるし、新なキーを
インデックスとして要素を代入すると要素を追加できる。
 wordoress["新書"]=10

長さ0の文字列やシーケンスをBOOL型として評価した時に、PYTHONはFALSE
と見なす

arglist(a,b,*c,**d) 混ぜたらエラーになる

PYTHONでファイルを操作する時は、open()という組み込み関数を使用し、
ファイルを操作するためのファイルオブジェクトを返す

リスト内包表記 [x*2+1 for x in range(2,10) if x%2==0]

イテレータの処理(next)
 次の要素を取り出す処理
 要素が終わったかどうかを判定する処理

イテレータ可能オブジェクトをイテレータオブジェクトに変換する
 iter(イテレート可能オブジェクト)

PYTHONの組み込み型は全てイテレート可能
 辞書はキーの一覧を返す
 ファイルオブジェクトは1行毎に返す

for文の(in イテレート可能)で自動的に変換される

ジェネレータ関数がyield文で値を返す点で普通の関数と異る
同じ関数内でreturnとyieldを両方使用することはできない

for文のelseはループ終了時に、whileのelseは条件がFalseになった
時に実行される。break時は実行されない


