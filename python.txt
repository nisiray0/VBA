PYTHONではすべてがオブジェクトである

PYTHONでは代入は参照の代入である。

PYTHONでは代入で変数を定義する。

PYTHONの組み込み型
 数値：短整数、長整数、浮動小数点、複素数
 文字列：8ビット文字列、ユニコード文字列
 リスト、タプル、辞書
 BOOL型、SET型、ファイル型

コレクション
 シーケンス：文字列、リスト、タプル
 マップ：辞書
 (文字列とタプルは変更不可）

myfunc=lamda x : x*2+1
            引数  戻り値の式
myfunc(5) 呼出し

RAW文字列 r"C:\Programfile\p.exe"
文字列では、"C:\\Programfile\\p.exe" (エスケープ)

PYTHONでは、複数の要素をカンマ(,)で列挙すると、タプルになる

PYTHONでは丸括弧をつけないで関数名を記述すると、関数をオブジェクトとして
扱える

辞書は、キーをインデックスとして要素を読み出せるし、新なキーを
インデックスとして要素を代入すると要素を追加できる。
 wordoress["新書"]=10

長さ0の文字列やシーケンスをBOOL型として評価した時に、PYTHONはFALSE
と見なす

arglist(a,b,*c,**d) 混ぜたらエラーになる

PYTHONでファイルを操作する時は、open()という組み込み関数を使用し、
ファイルを操作するためのファイルオブジェクトを返す

リスト内包表記 [x*2+1 for x in range(2,10) if x%2==0]

イテレータの処理(next)
 次の要素を取り出す処理
 要素が終わったかどうかを判定する処理

イテレータ可能オブジェクトをイテレータオブジェクトに変換する
 iter(イテレート可能オブジェクト)

PYTHONの組み込み型は全てイテレート可能
 辞書はキーの一覧を返す
 ファイルオブジェクトは1行毎に返す

for文の(in イテレート可能)で自動的に変換される

ジェネレータ関数がyield文で値を返す点で普通の関数と異る
同じ関数内でreturnとyieldを両方使用することはできない

for文のelseはループ終了時に、whileのelseは条件がFalseになった
時に実行される。break時は実行されない

PYTHONではオブジェクトの代入で変数を定義するが、インスタンスの
オブジェクトのアトリビュートも代入を行った時に定義される

メソッドには第一引数として必ずselfを指定する。メソッド呼出時には
自動的にselfが渡される

__init__(self,..)は初期化メソッドで、インスタンス生成時に自動的に
実行される

メソッド柱ではインスタンスのアトリビュートはself.xxxで指定する

import モジュール名 でモジュールオブジェクトにモジュールの関数等
を挿入される

from モジュール名 import 関数名やクラス名 でドットの左側にある
モジュール名（モジュールオブジェクト名）は省略できる

以下では、使用するときは、importに指定した名前にする
 import モジュール名
 from モジュール名 import 関数名かクラス名
 from パッケージ名 import モジュール名
 import パッケージ名.モジュール名

モジュールに、if __name__ == '__main__' というif文を設けると、
その部分はimport時には実行されない

パッケージの実体は、モジュールとなるファイルを納めたディレクトリ

パッケージのディレクトリには、__init__pyというファイルを配置する

配布パッケージのディレクトリにはたいていsetup.pyが入っており、
 python setup.py install でインストールする

サードパーティのライブラリはsite-packagesに配置する

